<?php

/**
 * @file
 * Valghalla_synch_node_export.module.
 */

/**
 * Implements hook_node_export_dependency_alter().
 */
function valghalla_synch_node_export_node_export_dependency_field_alter(&$handled, &$node, $dependency) {
  if (is_array($handled)) {
    foreach ($handled as $key => $element) {
      // Adding parent uuid, if not set already.
      if (!isset($handled[$key]['parent_uuid'])) {
        $handled[$key]['parent_uuid'] = $dependency->uuid;
      }
    }
  }
}

/**
 * Implements hook_node_export_node_alter().
 *
 * Addes the role UUID to the export info,
 * it is required for doing the mapping on the second server,
 * since role nid can be different.
 */
function valghalla_synch_node_export_node_export_node_alter(&$node, $original_node) {
  if ($node->type == 'election') {
    $node->roles_uuids = array();
    $roles_loaded = node_load_multiple(array_keys(odin_get_roles()));
    foreach ($roles_loaded as $role) {
      $node->roles_uuids[$role->nid] = $role->uuid;
    }
  }
}

/**
 * Implements hook_node_export_import_alter().
 *
 * Updates the references inside $node->node_export_dependency
 * to the local created objects.
 */
function valghalla_synch_node_export_node_export_import_alter(&$nodes, $format, $save) {
  foreach ($nodes as $node) {
    if (isset($node->node_export_dependency)) {
      // Do the role fields remapping.
      _valghalla_synch_node_export_role_remapping($node);

      // Find all field_collection_items.
      $field_collection_items = array();
      foreach ($node->node_export_dependency as $dep_key => $dependency) {
        if (isset($dependency['type']) && strcmp($dependency['type'], 'field_collection_item') === 0) {
          $field_collection_items[$dependency['uuid']] = $dep_key;
        }
      }

      foreach ($node->node_export_dependency as $dep_key => $dependency) {
        // If element has a different parent uuid than node.
        // This means it's not node's direct child.
        if (isset($dependency['type']) && isset($dependency['parent_uuid']) && strcmp($dependency['parent_uuid'], $node->uuid) !== 0) {
          unset($node->node_export_dependency[$dep_key]);

          // Try to find a parent.
          $parent_dep_key = $field_collection_items[$dependency['parent_uuid']];
          if (isset($parent_dep_key)) {
            // Find if that entity exists already.
            $entity_ids = entity_get_id_by_uuid($dependency['type'], array($dependency['uuid']));
            $entity_id = $entity_ids ? reset($entity_ids) : FALSE;

            // Finally set the value.
            if ($entity_id) {
              $node->node_export_dependency[$parent_dep_key]['node_export_field_collection_data'][$dependency['field_name']][$dependency['langcode']][$dependency['delta']][$dependency['property']] = $entity_id;
            }
          }
        }
      }
    }
  }
}

/**
 * Changes the keys of the role-related fields.
 *
 * Since the role fields are using nids in their name, which can be different
 * between installations, we are using UUIDs to rename the field according
 * to the local installation NIDs.
 *
 * @param mixed $node
 *   Node object to be altered.
 */
function _valghalla_synch_node_export_role_remapping(&$node) {
  // Find all field_collection_items.
  foreach ($node->node_export_dependency as $dep_key => $dependency) {
    if (isset($dependency['type']) && strcmp($dependency['type'], 'field_collection_item') === 0) {
      $new_roles_fields_data = array();

      // If field_collection_item is if type field_volunteers_pr_pol_st_party,
      // do the roles remapping, since role nid might be different.
      if (strcmp($dependency['field_name'], 'field_volunteers_pr_pol_st_party') === 0) {
        if (isset($dependency['node_export_field_collection_data']) && is_array($dependency['node_export_field_collection_data'])) {
          // First we traverse to extract the data, and remove the old key.
          foreach ($dependency['node_export_field_collection_data'] as $key => $element) {
            if (strpos($key, 'field_role_n') === 0) {
              $role_remote_nid = intval(str_replace('field_role_n', '', $key));
              $role_uuid = $node->roles_uuids[$role_remote_nid];
              if ($role_uuid) {
                $match = entity_get_id_by_uuid('node', array($role_uuid));
                $role_local_nid = intval($match[$role_uuid]);
                if ($role_local_nid !== $role_remote_nid) {
                  $new_key = 'field_role_n' . $role_local_nid;
                  $data = $node->node_export_dependency[$dep_key]['node_export_field_collection_data'][$key];
                  $new_roles_fields_data[$new_key] = $data;

                  // We don't need that value anymore, unset it.
                  unset($node->node_export_dependency[$dep_key]['node_export_field_collection_data'][$key]);
                }
              }
            }
          }

          // Then we use the saved data to set the value anew.
          foreach ($new_roles_fields_data as $role_field_key => $role_field_value) {
            $node->node_export_dependency[$dep_key]['node_export_field_collection_data'][$role_field_key] = $role_field_value;
          }
        }
      }
    }
  }
  unset($node->roles_uuids);
}

/**
 * Returns the name of the openssl method that is used for encryption.
 *
 * @return string
 *   Name of the encryption method.
 */
function valghalla_synch_node_export_get_encryption_method() {
  return 'aes-128-cbc';
}

/**
 * Returns initialization vector.
 */
function valghalla_synch_node_export_get_iv() {
  return '1234567890123456';
}

/**
 * Encrypts the data.
 *
 * If key is not provided, site hash salt is used.
 *
 * @param string $data
 *   Data to encrypt.
 * @param mixed $key
 *   The key.
 *
 * @return string
 *   Encrypted data.
 */
function valghalla_synch_node_export_get_encrypt($data, $key = NULL) {
  if (!$key) {
    $key = drupal_get_hash_salt();
  }
  $iv = valghalla_synch_node_export_get_iv();
  $method = valghalla_synch_node_export_get_encryption_method();
  return openssl_encrypt($data, $method, $key, 0, $iv);
}

/**
 * Decrypts the data.
 *
 * If key is not provided, site hash salt is used.
 *
 * @param string $encrypted_data
 *   Data to decrypt.
 * @param mixed $key
 *   The key.
 *
 * @return string
 *   Decrypted data.
 */
function valghalla_synch_node_export_get_decrypt($encrypted_data, $key = NULL) {
  if (!$key) {
    $key = drupal_get_hash_salt();
  }
  $iv = valghalla_synch_node_export_get_iv();
  $method = valghalla_synch_node_export_get_encryption_method();
  return openssl_decrypt($encrypted_data, $method, $key, 0, $iv);
}

/**
 * Anonymizes the volunteer node.
 *
 * Unsets the sensitive values and encrypts the CPR.
 *
 * @param mixed $node
 *   Volunteer node.
 * @param string $cipherKey
 *   Key to be used for encryption.
 *
 * @return mixed
 *   Anonymized volunteer node.
 */
function valghalla_synch_node_export_anonymize_node($node, $cipherKey = NULL) {
  // Do the anonymization for volunteers only.
  if ($node->type == 'volunteers') {
    $node->field_address_bnummer = array();
    $node->field_address_city = array();
    $node->field_address_coname = array();
    $node->field_address_door = array();
    $node->field_address_floor = array();
    $node->field_address_road = array();
    $node->field_address_road_no = array();
    $node->field_address_zipcode = array();
    $node->field_cpr_valid_date = array();
    $node->field_municipality = array();
    $node->field_phone2 = array();

    // Encrypting CPR field.
    $cpr_field_language = field_language('node', $node, 'field_cpr_number');
    $cpr = $node->field_cpr_number[$cpr_field_language][0]['value'];
    $cpr_encrypted = valghalla_synch_node_export_get_encrypt($cpr, $cipherKey);
    $node->field_cpr_number[$cpr_field_language][0]['value'] = $cpr_encrypted;

    // Encrypting email field.
    $email_field_language = field_language('node', $node, 'field_email');
    $email = $node->field_email[$email_field_language][0]['email'];
    $email_encrypted = valghalla_synch_node_export_get_encrypt($email, $cipherKey);
    $node->field_email[$email_field_language][0]['email'] = $email_encrypted;

    // Encrypting phone field.
    $phone_field_language = field_language('node', $node, 'field_phone');
    $phone = $node->field_phone[$phone_field_language][0]['value'];
    $phone_encrypted = valghalla_synch_node_export_get_encrypt($phone, $cipherKey);
    $node->field_phone[$phone_field_language][0]['value'] = $phone_encrypted;

    $node->title = 'Anonymized volunteer node, CPR: ' . $cpr_encrypted;
  }
  return $node;
}
